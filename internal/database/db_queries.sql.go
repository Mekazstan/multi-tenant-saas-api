// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: db_queries.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acceptTeamInvitation = `-- name: AcceptTeamInvitation :one
UPDATE team_invitations
SET accepted_at = NOW()
WHERE id = $1
RETURNING id, organization_id, email, role, invited_by, token, expires_at, accepted_at, declined_at, created_at
`

func (q *Queries) AcceptTeamInvitation(ctx context.Context, id uuid.UUID) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, acceptTeamInvitation, id)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.CreatedAt,
	)
	return i, err
}

const activateAPIKey = `-- name: ActivateAPIKey :one
UPDATE api_keys
SET is_active = true
WHERE id = $1
RETURNING id, organization_id, key, name, is_active, created_at, last_used_at
`

func (q *Queries) ActivateAPIKey(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, activateAPIKey, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Key,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const cancelInvitation = `-- name: CancelInvitation :one
UPDATE team_invitations
SET declined_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, email, role, invited_by, token, expires_at, accepted_at, declined_at, created_at
`

type CancelInvitationParams struct {
	ID             uuid.UUID `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) CancelInvitation(ctx context.Context, arg CancelInvitationParams) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, cancelInvitation, arg.ID, arg.OrganizationID)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.CreatedAt,
	)
	return i, err
}

const countOrganizationUsage = `-- name: CountOrganizationUsage :one
SELECT COUNT(*) FROM usage_records
WHERE organization_id = $1
    AND created_at >= $2
    AND created_at <= $3
`

type CountOrganizationUsageParams struct {
	OrganizationID uuid.UUID        `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	CreatedAt_2    pgtype.Timestamp `json:"created_at_2"`
}

func (q *Queries) CountOrganizationUsage(ctx context.Context, arg CountOrganizationUsageParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrganizationUsage, arg.OrganizationID, arg.CreatedAt, arg.CreatedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :one

INSERT INTO api_keys (organization_id, key, name, is_active)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, key, name, is_active, created_at, last_used_at
`

type CreateAPIKeyParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Key            string    `json:"key"`
	Name           string    `json:"name"`
	IsActive       bool      `json:"is_active"`
}

// ============================================
// API KEY QUERIES
// ============================================
func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, createAPIKey,
		arg.OrganizationID,
		arg.Key,
		arg.Name,
		arg.IsActive,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Key,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const createAuthToken = `-- name: CreateAuthToken :one
INSERT INTO auth_tokens (user_id, token, type, expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, token, type, expires_at, used_at, created_at
`

type CreateAuthTokenParams struct {
	UserID    pgtype.UUID      `json:"user_id"`
	Token     string           `json:"token"`
	Type      TokenType        `json:"type"`
	ExpiresAt pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateAuthToken(ctx context.Context, arg CreateAuthTokenParams) (AuthToken, error) {
	row := q.db.QueryRow(ctx, createAuthToken,
		arg.UserID,
		arg.Token,
		arg.Type,
		arg.ExpiresAt,
	)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Type,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createBillingCycle = `-- name: CreateBillingCycle :one

INSERT INTO billing_cycles (
    organization_id,
    period_start,
    period_end,
    total_requests,
    total_amount,
    status
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, period_start, period_end, total_requests, total_amount, status, created_at
`

type CreateBillingCycleParams struct {
	OrganizationID uuid.UUID        `json:"organization_id"`
	PeriodStart    pgtype.Timestamp `json:"period_start"`
	PeriodEnd      pgtype.Timestamp `json:"period_end"`
	TotalRequests  int32            `json:"total_requests"`
	TotalAmount    pgtype.Numeric   `json:"total_amount"`
	Status         BillingStatus    `json:"status"`
}

// ============================================
// BILLING CYCLE QUERIES
// ============================================
func (q *Queries) CreateBillingCycle(ctx context.Context, arg CreateBillingCycleParams) (BillingCycle, error) {
	row := q.db.QueryRow(ctx, createBillingCycle,
		arg.OrganizationID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.TotalRequests,
		arg.TotalAmount,
		arg.Status,
	)
	var i BillingCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalRequests,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (name, email, plan)
VALUES ($1, $2, $3)
RETURNING id, name, email, plan, created_at, updated_at
`

type CreateOrganizationParams struct {
	Name  string   `json:"name"`
	Email string   `json:"email"`
	Plan  PlanType `json:"plan"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization, arg.Name, arg.Email, arg.Plan)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTeamInvitation = `-- name: CreateTeamInvitation :one
INSERT INTO team_invitations (organization_id, email, role, invited_by, token, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, organization_id, email, role, invited_by, token, expires_at, accepted_at, declined_at, created_at
`

type CreateTeamInvitationParams struct {
	OrganizationID uuid.UUID        `json:"organization_id"`
	Email          string           `json:"email"`
	Role           UserRole         `json:"role"`
	InvitedBy      uuid.UUID        `json:"invited_by"`
	Token          string           `json:"token"`
	ExpiresAt      pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateTeamInvitation(ctx context.Context, arg CreateTeamInvitationParams) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, createTeamInvitation,
		arg.OrganizationID,
		arg.Email,
		arg.Role,
		arg.InvitedBy,
		arg.Token,
		arg.ExpiresAt,
	)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUsageRecord = `-- name: CreateUsageRecord :one

INSERT INTO usage_records (organization_id, api_key_id, endpoint, method, status_code)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, organization_id, api_key_id, endpoint, method, status_code, created_at
`

type CreateUsageRecordParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	ApiKeyID       uuid.UUID `json:"api_key_id"`
	Endpoint       string    `json:"endpoint"`
	Method         string    `json:"method"`
	StatusCode     int32     `json:"status_code"`
}

// ============================================
// USAGE RECORD QUERIES
// ============================================
func (q *Queries) CreateUsageRecord(ctx context.Context, arg CreateUsageRecordParams) (UsageRecord, error) {
	row := q.db.QueryRow(ctx, createUsageRecord,
		arg.OrganizationID,
		arg.ApiKeyID,
		arg.Endpoint,
		arg.Method,
		arg.StatusCode,
	)
	var i UsageRecord
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ApiKeyID,
		&i.Endpoint,
		&i.Method,
		&i.StatusCode,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (organization_id, email, password_hash, role)
VALUES ($1, $2, $3, $4)
RETURNING id, organization_id, email, password_hash, role, created_at, email_verified, email_verified_at
`

type CreateUserParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Email          string    `json:"email"`
	PasswordHash   string    `json:"password_hash"`
	Role           UserRole  `json:"role"`
}

// ============================================
// USER QUERIES
// ============================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.OrganizationID,
		arg.Email,
		arg.PasswordHash,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const deactivateAPIKey = `-- name: DeactivateAPIKey :one
UPDATE api_keys
SET is_active = false
WHERE id = $1
RETURNING id, organization_id, key, name, is_active, created_at, last_used_at
`

func (q *Queries) DeactivateAPIKey(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, deactivateAPIKey, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Key,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const declineTeamInvitation = `-- name: DeclineTeamInvitation :one
UPDATE team_invitations
SET declined_at = NOW()
WHERE id = $1
RETURNING id, organization_id, email, role, invited_by, token, expires_at, accepted_at, declined_at, created_at
`

func (q *Queries) DeclineTeamInvitation(ctx context.Context, id uuid.UUID) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, declineTeamInvitation, id)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys
WHERE id = $1
`

func (q *Queries) DeleteAPIKey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAPIKey, id)
	return err
}

const deleteExpiredInvitations = `-- name: DeleteExpiredInvitations :exec
DELETE FROM team_invitations
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredInvitations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredInvitations)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM auth_tokens
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredTokens)
	return err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrganization, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getAPIKey = `-- name: GetAPIKey :one
SELECT id, organization_id, key, name, is_active, created_at, last_used_at FROM api_keys
WHERE id = $1
`

func (q *Queries) GetAPIKey(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKey, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Key,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getAPIKeyByKey = `-- name: GetAPIKeyByKey :one
SELECT 
    ak.id, ak.organization_id, ak.key, ak.name, ak.is_active, ak.created_at, ak.last_used_at,
    o.id as org_id,
    o.name as org_name,
    o.plan as org_plan
FROM api_keys ak
JOIN organizations o ON ak.organization_id = o.id
WHERE ak.key = $1 AND ak.is_active = true
`

type GetAPIKeyByKeyRow struct {
	ID             uuid.UUID        `json:"id"`
	OrganizationID uuid.UUID        `json:"organization_id"`
	Key            string           `json:"key"`
	Name           string           `json:"name"`
	IsActive       bool             `json:"is_active"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	LastUsedAt     pgtype.Timestamp `json:"last_used_at"`
	OrgID          uuid.UUID        `json:"org_id"`
	OrgName        string           `json:"org_name"`
	OrgPlan        PlanType         `json:"org_plan"`
}

func (q *Queries) GetAPIKeyByKey(ctx context.Context, key string) (GetAPIKeyByKeyRow, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByKey, key)
	var i GetAPIKeyByKeyRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Key,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.OrgID,
		&i.OrgName,
		&i.OrgPlan,
	)
	return i, err
}

const getAuthToken = `-- name: GetAuthToken :one
SELECT id, user_id, token, type, expires_at, used_at, created_at FROM auth_tokens
WHERE token = $1 AND used_at IS NULL AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetAuthToken(ctx context.Context, token string) (AuthToken, error) {
	row := q.db.QueryRow(ctx, getAuthToken, token)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Type,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getBillingCycle = `-- name: GetBillingCycle :one
SELECT id, organization_id, period_start, period_end, total_requests, total_amount, status, created_at FROM billing_cycles
WHERE id = $1
`

func (q *Queries) GetBillingCycle(ctx context.Context, id uuid.UUID) (BillingCycle, error) {
	row := q.db.QueryRow(ctx, getBillingCycle, id)
	var i BillingCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalRequests,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getCurrentBillingCycle = `-- name: GetCurrentBillingCycle :one
SELECT id, organization_id, period_start, period_end, total_requests, total_amount, status, created_at FROM billing_cycles
WHERE organization_id = $1
    AND period_start <= NOW()
    AND period_end >= NOW()
ORDER BY period_start DESC
LIMIT 1
`

func (q *Queries) GetCurrentBillingCycle(ctx context.Context, organizationID uuid.UUID) (BillingCycle, error) {
	row := q.db.QueryRow(ctx, getCurrentBillingCycle, organizationID)
	var i BillingCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalRequests,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getDailyUsageStats = `-- name: GetDailyUsageStats :many
SELECT 
    DATE(created_at) as date,
    COUNT(*) as request_count,
    COUNT(CASE WHEN status_code >= 200 AND status_code < 300 THEN 1 END) as success_count,
    COUNT(CASE WHEN status_code >= 400 THEN 1 END) as error_count
FROM usage_records
WHERE organization_id = $1
    AND created_at >= $2
    AND created_at <= $3
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetDailyUsageStatsParams struct {
	OrganizationID uuid.UUID        `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	CreatedAt_2    pgtype.Timestamp `json:"created_at_2"`
}

type GetDailyUsageStatsRow struct {
	Date         pgtype.Date `json:"date"`
	RequestCount int64       `json:"request_count"`
	SuccessCount int64       `json:"success_count"`
	ErrorCount   int64       `json:"error_count"`
}

func (q *Queries) GetDailyUsageStats(ctx context.Context, arg GetDailyUsageStatsParams) ([]GetDailyUsageStatsRow, error) {
	rows, err := q.db.Query(ctx, getDailyUsageStats, arg.OrganizationID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyUsageStatsRow{}
	for rows.Next() {
		var i GetDailyUsageStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.RequestCount,
			&i.SuccessCount,
			&i.ErrorCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, name, email, plan, created_at, updated_at FROM organizations
WHERE id = $1
`

func (q *Queries) GetOrganization(ctx context.Context, id uuid.UUID) (Organization, error) {
	row := q.db.QueryRow(ctx, getOrganization, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationByEmail = `-- name: GetOrganizationByEmail :one
SELECT id, name, email, plan, created_at, updated_at FROM organizations
WHERE email = $1
`

func (q *Queries) GetOrganizationByEmail(ctx context.Context, email string) (Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationByEmail, email)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOverdueBillingCycles = `-- name: GetOverdueBillingCycles :many
SELECT 
    bc.id, bc.organization_id, bc.period_start, bc.period_end, bc.total_requests, bc.total_amount, bc.status, bc.created_at,
    o.name as organization_name,
    o.email as organization_email
FROM billing_cycles bc
JOIN organizations o ON bc.organization_id = o.id
WHERE bc.status = 'overdue'
ORDER BY bc.period_end ASC
`

type GetOverdueBillingCyclesRow struct {
	ID                uuid.UUID        `json:"id"`
	OrganizationID    uuid.UUID        `json:"organization_id"`
	PeriodStart       pgtype.Timestamp `json:"period_start"`
	PeriodEnd         pgtype.Timestamp `json:"period_end"`
	TotalRequests     int32            `json:"total_requests"`
	TotalAmount       pgtype.Numeric   `json:"total_amount"`
	Status            BillingStatus    `json:"status"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	OrganizationName  string           `json:"organization_name"`
	OrganizationEmail string           `json:"organization_email"`
}

func (q *Queries) GetOverdueBillingCycles(ctx context.Context) ([]GetOverdueBillingCyclesRow, error) {
	rows, err := q.db.Query(ctx, getOverdueBillingCycles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverdueBillingCyclesRow{}
	for rows.Next() {
		var i GetOverdueBillingCyclesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.TotalRequests,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.OrganizationName,
			&i.OrganizationEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingBillingCycles = `-- name: GetPendingBillingCycles :many
SELECT 
    bc.id, bc.organization_id, bc.period_start, bc.period_end, bc.total_requests, bc.total_amount, bc.status, bc.created_at,
    o.name as organization_name,
    o.email as organization_email
FROM billing_cycles bc
JOIN organizations o ON bc.organization_id = o.id
WHERE bc.status = 'pending'
    AND bc.period_end < NOW()
ORDER BY bc.period_end ASC
`

type GetPendingBillingCyclesRow struct {
	ID                uuid.UUID        `json:"id"`
	OrganizationID    uuid.UUID        `json:"organization_id"`
	PeriodStart       pgtype.Timestamp `json:"period_start"`
	PeriodEnd         pgtype.Timestamp `json:"period_end"`
	TotalRequests     int32            `json:"total_requests"`
	TotalAmount       pgtype.Numeric   `json:"total_amount"`
	Status            BillingStatus    `json:"status"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	OrganizationName  string           `json:"organization_name"`
	OrganizationEmail string           `json:"organization_email"`
}

func (q *Queries) GetPendingBillingCycles(ctx context.Context) ([]GetPendingBillingCyclesRow, error) {
	rows, err := q.db.Query(ctx, getPendingBillingCycles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingBillingCyclesRow{}
	for rows.Next() {
		var i GetPendingBillingCyclesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.TotalRequests,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.OrganizationName,
			&i.OrganizationEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvitationByEmail = `-- name: GetPendingInvitationByEmail :one
SELECT id, organization_id, email, role, invited_by, token, expires_at, accepted_at, declined_at, created_at FROM team_invitations
WHERE organization_id = $1 
  AND email = $2 
  AND accepted_at IS NULL 
  AND declined_at IS NULL
LIMIT 1
`

type GetPendingInvitationByEmailParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Email          string    `json:"email"`
}

func (q *Queries) GetPendingInvitationByEmail(ctx context.Context, arg GetPendingInvitationByEmailParams) (TeamInvitation, error) {
	row := q.db.QueryRow(ctx, getPendingInvitationByEmail, arg.OrganizationID, arg.Email)
	var i TeamInvitation
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTeamInvitationByToken = `-- name: GetTeamInvitationByToken :one
SELECT 
    ti.id, ti.organization_id, ti.email, ti.role, ti.invited_by, ti.token, ti.expires_at, ti.accepted_at, ti.declined_at, ti.created_at,
    o.name as organization_name,
    u.email as inviter_email
FROM team_invitations ti
JOIN organizations o ON ti.organization_id = o.id
JOIN users u ON ti.invited_by = u.id
WHERE ti.token = $1 
  AND ti.accepted_at IS NULL 
  AND ti.declined_at IS NULL 
  AND ti.expires_at > NOW()
LIMIT 1
`

type GetTeamInvitationByTokenRow struct {
	ID               uuid.UUID        `json:"id"`
	OrganizationID   uuid.UUID        `json:"organization_id"`
	Email            string           `json:"email"`
	Role             UserRole         `json:"role"`
	InvitedBy        uuid.UUID        `json:"invited_by"`
	Token            string           `json:"token"`
	ExpiresAt        pgtype.Timestamp `json:"expires_at"`
	AcceptedAt       pgtype.Timestamp `json:"accepted_at"`
	DeclinedAt       pgtype.Timestamp `json:"declined_at"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	OrganizationName string           `json:"organization_name"`
	InviterEmail     string           `json:"inviter_email"`
}

func (q *Queries) GetTeamInvitationByToken(ctx context.Context, token string) (GetTeamInvitationByTokenRow, error) {
	row := q.db.QueryRow(ctx, getTeamInvitationByToken, token)
	var i GetTeamInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.DeclinedAt,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.InviterEmail,
	)
	return i, err
}

const getUsageByAPIKey = `-- name: GetUsageByAPIKey :many
SELECT 
    ak.id,
    ak.name,
    ak.key,
    COUNT(ur.id) as request_count
FROM api_keys ak
LEFT JOIN usage_records ur ON ak.id = ur.api_key_id
    AND ur.created_at >= $2
    AND ur.created_at <= $3
WHERE ak.organization_id = $1
GROUP BY ak.id, ak.name, ak.key
ORDER BY request_count DESC
`

type GetUsageByAPIKeyParams struct {
	OrganizationID uuid.UUID        `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	CreatedAt_2    pgtype.Timestamp `json:"created_at_2"`
}

type GetUsageByAPIKeyRow struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	Key          string    `json:"key"`
	RequestCount int64     `json:"request_count"`
}

func (q *Queries) GetUsageByAPIKey(ctx context.Context, arg GetUsageByAPIKeyParams) ([]GetUsageByAPIKeyRow, error) {
	rows, err := q.db.Query(ctx, getUsageByAPIKey, arg.OrganizationID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageByAPIKeyRow{}
	for rows.Next() {
		var i GetUsageByAPIKeyRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Key,
			&i.RequestCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageByEndpoint = `-- name: GetUsageByEndpoint :many
SELECT 
    endpoint,
    COUNT(*) as request_count,
    COUNT(CASE WHEN status_code >= 200 AND status_code < 300 THEN 1 END) as success_count,
    COUNT(CASE WHEN status_code >= 400 THEN 1 END) as error_count
FROM usage_records
WHERE organization_id = $1
    AND created_at >= $2
    AND created_at <= $3
GROUP BY endpoint
ORDER BY request_count DESC
`

type GetUsageByEndpointParams struct {
	OrganizationID uuid.UUID        `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	CreatedAt_2    pgtype.Timestamp `json:"created_at_2"`
}

type GetUsageByEndpointRow struct {
	Endpoint     string `json:"endpoint"`
	RequestCount int64  `json:"request_count"`
	SuccessCount int64  `json:"success_count"`
	ErrorCount   int64  `json:"error_count"`
}

func (q *Queries) GetUsageByEndpoint(ctx context.Context, arg GetUsageByEndpointParams) ([]GetUsageByEndpointRow, error) {
	rows, err := q.db.Query(ctx, getUsageByEndpoint, arg.OrganizationID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageByEndpointRow{}
	for rows.Next() {
		var i GetUsageByEndpointRow
		if err := rows.Scan(
			&i.Endpoint,
			&i.RequestCount,
			&i.SuccessCount,
			&i.ErrorCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageRecord = `-- name: GetUsageRecord :one
SELECT id, organization_id, api_key_id, endpoint, method, status_code, created_at FROM usage_records
WHERE id = $1
`

func (q *Queries) GetUsageRecord(ctx context.Context, id uuid.UUID) (UsageRecord, error) {
	row := q.db.QueryRow(ctx, getUsageRecord, id)
	var i UsageRecord
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ApiKeyID,
		&i.Endpoint,
		&i.Method,
		&i.StatusCode,
		&i.CreatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, organization_id, email, password_hash, role, created_at, email_verified, email_verified_at FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, organization_id, email, password_hash, role, created_at, email_verified, email_verified_at FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getUserWithOrganization = `-- name: GetUserWithOrganization :one
SELECT 
    u.id, u.organization_id, u.email, u.password_hash, u.role, u.created_at, u.email_verified, u.email_verified_at,
    o.name as organization_name,
    o.plan as organization_plan
FROM users u
JOIN organizations o ON u.organization_id = o.id
WHERE u.id = $1
`

type GetUserWithOrganizationRow struct {
	ID               uuid.UUID        `json:"id"`
	OrganizationID   uuid.UUID        `json:"organization_id"`
	Email            string           `json:"email"`
	PasswordHash     string           `json:"password_hash"`
	Role             UserRole         `json:"role"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	EmailVerified    bool             `json:"email_verified"`
	EmailVerifiedAt  pgtype.Timestamp `json:"email_verified_at"`
	OrganizationName string           `json:"organization_name"`
	OrganizationPlan PlanType         `json:"organization_plan"`
}

func (q *Queries) GetUserWithOrganization(ctx context.Context, id uuid.UUID) (GetUserWithOrganizationRow, error) {
	row := q.db.QueryRow(ctx, getUserWithOrganization, id)
	var i GetUserWithOrganizationRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.OrganizationName,
		&i.OrganizationPlan,
	)
	return i, err
}

const listOrganizationAPIKeys = `-- name: ListOrganizationAPIKeys :many
SELECT id, organization_id, key, name, is_active, created_at, last_used_at FROM api_keys
WHERE organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListOrganizationAPIKeys(ctx context.Context, organizationID uuid.UUID) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listOrganizationAPIKeys, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Key,
			&i.Name,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationBillingCycles = `-- name: ListOrganizationBillingCycles :many
SELECT id, organization_id, period_start, period_end, total_requests, total_amount, status, created_at FROM billing_cycles
WHERE organization_id = $1
ORDER BY period_start DESC
LIMIT $2 OFFSET $3
`

type ListOrganizationBillingCyclesParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

func (q *Queries) ListOrganizationBillingCycles(ctx context.Context, arg ListOrganizationBillingCyclesParams) ([]BillingCycle, error) {
	rows, err := q.db.Query(ctx, listOrganizationBillingCycles, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillingCycle{}
	for rows.Next() {
		var i BillingCycle
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.TotalRequests,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationInvitations = `-- name: ListOrganizationInvitations :many
SELECT 
    ti.id, ti.organization_id, ti.email, ti.role, ti.invited_by, ti.token, ti.expires_at, ti.accepted_at, ti.declined_at, ti.created_at,
    u.email as inviter_email
FROM team_invitations ti
JOIN users u ON ti.invited_by = u.id
WHERE ti.organization_id = $1
ORDER BY ti.created_at DESC
`

type ListOrganizationInvitationsRow struct {
	ID             uuid.UUID        `json:"id"`
	OrganizationID uuid.UUID        `json:"organization_id"`
	Email          string           `json:"email"`
	Role           UserRole         `json:"role"`
	InvitedBy      uuid.UUID        `json:"invited_by"`
	Token          string           `json:"token"`
	ExpiresAt      pgtype.Timestamp `json:"expires_at"`
	AcceptedAt     pgtype.Timestamp `json:"accepted_at"`
	DeclinedAt     pgtype.Timestamp `json:"declined_at"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	InviterEmail   string           `json:"inviter_email"`
}

func (q *Queries) ListOrganizationInvitations(ctx context.Context, organizationID uuid.UUID) ([]ListOrganizationInvitationsRow, error) {
	rows, err := q.db.Query(ctx, listOrganizationInvitations, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationInvitationsRow{}
	for rows.Next() {
		var i ListOrganizationInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Email,
			&i.Role,
			&i.InvitedBy,
			&i.Token,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.DeclinedAt,
			&i.CreatedAt,
			&i.InviterEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT 
    u.id,
    u.email,
    u.role,
    u.email_verified,
    u.created_at
FROM users u
WHERE u.organization_id = $1
ORDER BY u.created_at DESC
`

type ListOrganizationMembersRow struct {
	ID            uuid.UUID        `json:"id"`
	Email         string           `json:"email"`
	Role          UserRole         `json:"role"`
	EmailVerified bool             `json:"email_verified"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, organizationID uuid.UUID) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.Query(ctx, listOrganizationMembers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationMembersRow{}
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Role,
			&i.EmailVerified,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationUsage = `-- name: ListOrganizationUsage :many
SELECT id, organization_id, api_key_id, endpoint, method, status_code, created_at FROM usage_records
WHERE organization_id = $1
    AND created_at >= $2
    AND created_at <= $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListOrganizationUsageParams struct {
	OrganizationID uuid.UUID        `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	CreatedAt_2    pgtype.Timestamp `json:"created_at_2"`
	Limit          int32            `json:"limit"`
	Offset         int32            `json:"offset"`
}

func (q *Queries) ListOrganizationUsage(ctx context.Context, arg ListOrganizationUsageParams) ([]UsageRecord, error) {
	rows, err := q.db.Query(ctx, listOrganizationUsage,
		arg.OrganizationID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageRecord{}
	for rows.Next() {
		var i UsageRecord
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ApiKeyID,
			&i.Endpoint,
			&i.Method,
			&i.StatusCode,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationUsers = `-- name: ListOrganizationUsers :many
SELECT id, organization_id, email, password_hash, role, created_at, email_verified, email_verified_at FROM users
WHERE organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListOrganizationUsers(ctx context.Context, organizationID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, listOrganizationUsers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Email,
			&i.PasswordHash,
			&i.Role,
			&i.CreatedAt,
			&i.EmailVerified,
			&i.EmailVerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name, email, plan, created_at, updated_at FROM organizations
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOrganizationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListOrganizations(ctx context.Context, arg ListOrganizationsParams) ([]Organization, error) {
	rows, err := q.db.Query(ctx, listOrganizations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Plan,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTokenAsUsed = `-- name: MarkTokenAsUsed :one
UPDATE auth_tokens
SET used_at = NOW()
WHERE id = $1
RETURNING id, user_id, token, type, expires_at, used_at, created_at
`

func (q *Queries) MarkTokenAsUsed(ctx context.Context, id uuid.UUID) (AuthToken, error) {
	row := q.db.QueryRow(ctx, markTokenAsUsed, id)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Type,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const removeTeamMember = `-- name: RemoveTeamMember :exec
DELETE FROM users
WHERE id = $1 AND organization_id = $2 AND role != 'owner'
`

type RemoveTeamMemberParams struct {
	ID             uuid.UUID `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) RemoveTeamMember(ctx context.Context, arg RemoveTeamMemberParams) error {
	_, err := q.db.Exec(ctx, removeTeamMember, arg.ID, arg.OrganizationID)
	return err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys
SET last_used_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateAPIKeyLastUsed, id)
	return err
}

const updateBillingCycleStatus = `-- name: UpdateBillingCycleStatus :one
UPDATE billing_cycles
SET status = $1
WHERE id = $2
RETURNING id, organization_id, period_start, period_end, total_requests, total_amount, status, created_at
`

type UpdateBillingCycleStatusParams struct {
	Status BillingStatus `json:"status"`
	ID     uuid.UUID     `json:"id"`
}

func (q *Queries) UpdateBillingCycleStatus(ctx context.Context, arg UpdateBillingCycleStatusParams) (BillingCycle, error) {
	row := q.db.QueryRow(ctx, updateBillingCycleStatus, arg.Status, arg.ID)
	var i BillingCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalRequests,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateBillingCycleTotals = `-- name: UpdateBillingCycleTotals :one
UPDATE billing_cycles
SET 
    total_requests = $1,
    total_amount = $2
WHERE id = $3
RETURNING id, organization_id, period_start, period_end, total_requests, total_amount, status, created_at
`

type UpdateBillingCycleTotalsParams struct {
	TotalRequests int32          `json:"total_requests"`
	TotalAmount   pgtype.Numeric `json:"total_amount"`
	ID            uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateBillingCycleTotals(ctx context.Context, arg UpdateBillingCycleTotalsParams) (BillingCycle, error) {
	row := q.db.QueryRow(ctx, updateBillingCycleTotals, arg.TotalRequests, arg.TotalAmount, arg.ID)
	var i BillingCycle
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalRequests,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateOrganizationPlan = `-- name: UpdateOrganizationPlan :one
UPDATE organizations
SET plan = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, name, email, plan, created_at, updated_at
`

type UpdateOrganizationPlanParams struct {
	Plan PlanType  `json:"plan"`
	ID   uuid.UUID `json:"id"`
}

func (q *Queries) UpdateOrganizationPlan(ctx context.Context, arg UpdateOrganizationPlanParams) (Organization, error) {
	row := q.db.QueryRow(ctx, updateOrganizationPlan, arg.Plan, arg.ID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users
SET password_hash = $1
WHERE id = $2
RETURNING id, organization_id, email, password_hash, role, created_at, email_verified, email_verified_at
`

type UpdateUserPasswordParams struct {
	PasswordHash string    `json:"password_hash"`
	ID           uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET role = $1
WHERE id = $2 AND organization_id = $3 AND role != 'owner'
RETURNING id, organization_id, email, password_hash, role, created_at, email_verified, email_verified_at
`

type UpdateUserRoleParams struct {
	Role           UserRole  `json:"role"`
	ID             uuid.UUID `json:"id"`
	OrganizationID uuid.UUID `json:"organization_id"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID, arg.OrganizationID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const verifyUserEmail = `-- name: VerifyUserEmail :one
UPDATE users
SET email_verified = true, email_verified_at = NOW()
WHERE id = $1
RETURNING id, organization_id, email, password_hash, role, created_at, email_verified, email_verified_at
`

func (q *Queries) VerifyUserEmail(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, verifyUserEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}
